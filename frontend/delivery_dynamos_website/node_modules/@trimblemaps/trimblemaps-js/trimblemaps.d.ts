// Types for TrimbleMaps
// TypeScript Version: 3.0

import * as GeoJSON from './geojson';

export = TrimbleMaps;
export as namespace TrimbleMaps;

declare namespace TrimbleMaps {
    let APIKey: string;
    let version: string;
    let baseApiUrl: string;
    let APIToken: string;
    let TIDToken: object;
    let UNIT: typeof Common.Unit[keyof typeof Common.Unit];

    // export function setAPIKey(value: string): void;

    /**
     * Number of web workers instantiated on a page with GL JS maps.
     * By default, it is set to half the number of CPU cores (capped at 6).
     */
    let workerCount: number;

    /**
     * Maximum number of images (raster tiles, sprites, icons) to load in parallel, which affects performance in raster-heavy maps.
     * 16 by default.
     */
    let maxParallelImageRequests: number;

    export function setAPIKey(key: string): void;
    export function setAPIToken(token: string): void;
    export function setTIDToken(tidToken: object): void;

    
    /**
     * Unit to be used for route report calls.
     * If set, this unit will be used for conversions.
     * Based on the Unit, Truck Restriction value will be shown.
     * Based on the Unit, Vehicle Dimesnsions values will be converted in the route requets payload
     */
    export function setUnit(unit: typeof Common.Unit[keyof typeof Common.Unit]): void;

    export function supported(options?: { failIfMajorPerformanceCaveat?: boolean }): boolean;

    /**
     * Clears browser storage used by this library. Using this method flushes the TrimbleMaps tile cache that is managed by this library.
     * Tiles may still be cached by the browser in some cases.
     */
    export function clearStorage(callback?: (err?: Error) => void): void;

    export function setRTLTextPlugin(pluginURL: string, callback: (error: Error) => void, deferred?: boolean): void;
    export function getRTLTextPluginStatus(): PluginStatus;

    /**
     * Initializes resources like WebWorkers that can be shared across maps to lower load
     * times in some situations. `TrimbleMaps.workerUrl` and `TrimbleMaps.workerCount`, if being
     * used, must be set before `prewarm()` is called to have an effect.
     *
     * By default, the lifecycle of these resources is managed automatically, and they are
     * lazily initialized when a Map is first created. By invoking `prewarm()`, these
     * resources will be created ahead of time, and will not be cleared when the last Map
     * is removed from the page. This allows them to be re-used by new Map instances that
     * are created later. They can be manually cleared by calling
     * `TrimbleMaps.clearPrewarmedResources()`. This is only necessary if your web page remains
     * active but stops using maps altogether.
     *
     * This is primarily useful when using GL-JS maps in a single page app, wherein a user
     * would navigate between various views that can cause Map instances to constantly be
     * created and destroyed.
     */
    export function prewarm(): void;

    /**
     * Clears up resources that have previously been created by `TrimbleMaps.prewarm()`.
     * Note that this is typically not necessary. You should only call this function
     * if you expect the user of your app to not return to a Map view at any point
     * in your application.
     */
    export function clearPrewarmedResources(): void;

    type PluginStatus = 'unavailable' | 'loading' | 'loaded' | 'error';

    type LngLatLike =
        | [number, number]
        | LngLat
        | { lng: number; lat: number }
        | { lon: number; lat: number }
        | [number, number];

    type LngLatBoundsLike = LngLatBounds | [LngLatLike, LngLatLike] | [number, number, number, number] | LngLatLike;
    type PointLike = Point | [number, number];

    type ExpressionName =
        // Types
        | 'array'
        | 'boolean'
        | 'collator'
        | 'format'
        | 'literal'
        | 'number'
        | 'object'
        | 'string'
        | 'image'
        | 'to-boolean'
        | 'to-color'
        | 'to-number'
        | 'to-string'
        | 'typeof'
        // Feature data
        | 'feature-state'
        | 'geometry-type'
        | 'id'
        | 'line-progress'
        | 'properties'
        // Lookup
        | 'at'
        | 'get'
        | 'has'
        | 'in'
        | 'index-of'
        | 'length'
        | 'slice'
        // Decision
        | '!'
        | '!='
        | '<'
        | '<='
        | '=='
        | '>'
        | '>='
        | 'all'
        | 'any'
        | 'case'
        | 'match'
        | 'coalesce'
        // Ramps, scales, curves
        | 'interpolate'
        | 'interpolate-hcl'
        | 'interpolate-lab'
        | 'step'
        // Variable binding
        | 'let'
        | 'var'
        // String
        | 'concat'
        | 'downcase'
        | 'is-supported-script'
        | 'resolved-locale'
        | 'upcase'
        // Color
        | 'rgb'
        | 'rgba'
        // Math
        | '-'
        | '*'
        | '/'
        | '%'
        | '^'
        | '+'
        | 'abs'
        | 'acos'
        | 'asin'
        | 'atan'
        | 'ceil'
        | 'cos'
        | 'e'
        | 'floor'
        | 'ln'
        | 'ln2'
        | 'log10'
        | 'log2'
        | 'max'
        | 'min'
        | 'pi'
        | 'round'
        | 'sin'
        | 'sqrt'
        | 'tan'
        // Zoom, Heatmap
        | 'zoom'
        | 'heatmap-density';

    type Expression = [ExpressionName, ...any[]];

    type Anchor =
        | 'center'
        | 'left'
        | 'right'
        | 'top'
        | 'bottom'
        | 'top-left'
        | 'top-right'
        | 'bottom-left'
        | 'bottom-right';

    /**
     * Map
     */
    export class Map extends Evented {
        constructor(options?: MapOptions);

        addControl(
            control: Control | IControl,
            position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left',
        ): this;

        removeControl(control: Control | IControl): this;

        resize(eventData?: EventData): this;

        getBounds(): LngLatBounds;

        getMaxBounds(): LngLatBounds | null;

        setMaxBounds(lnglatbounds?: LngLatBoundsLike): this;

        setMinZoom(minZoom?: number | null): this;

        getMinZoom(): number;

        setMaxZoom(maxZoom?: number | null): this;

        getMaxZoom(): number;

        setMinPitch(minPitch?: number | null): this;

        getMinPitch(): number;

        setMaxPitch(maxPitch?: number | null): this;

        getMaxPitch(): number;

        getRenderWorldCopies(): boolean;

        setRenderWorldCopies(renderWorldCopies?: boolean): this;

        project(lnglat: LngLatLike): TrimbleMaps.Point;

        unproject(point: PointLike): TrimbleMaps.LngLat;

        isMoving(): boolean;

        isZooming(): boolean;

        isRotating(): boolean;

        /**
         * Returns an array of GeoJSON Feature objects representing visible features that satisfy the query parameters.
         *
         * The properties value of each returned feature object contains the properties of its source feature. For GeoJSON sources, only string and numeric property values are supported (i.e. null, Array, and Object values are not supported).
         *
         * Each feature includes top-level layer, source, and sourceLayer properties. The layer property is an object representing the style layer to which the feature belongs. Layout and paint properties in this object contain values which are fully evaluated for the given zoom level and feature.
         *
         * Only features that are currently rendered are included. Some features will not be included, like:
         *
         * - Features from layers whose visibility property is "none".
         * - Features from layers whose zoom range excludes the current zoom level.
         * - Symbol features that have been hidden due to text or icon collision.
         *
         * Features from all other layers are included, including features that may have no visible contribution to the rendered result; for example, because the layer's opacity or color alpha component is set to 0.
         *
         * The topmost rendered feature appears first in the returned array, and subsequent features are sorted by descending z-order. Features that are rendered multiple times (due to wrapping across the antimeridian at low zoom levels) are returned only once (though subject to the following caveat).
         *
         * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple times in query results. For example, suppose there is a highway running through the bounding rectangle of a query. The results of the query will be those parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple tiles due to tile buffering.
         *
         * @param pointOrBox The geometry of the query region: either a single point or southwest and northeast points describing a bounding box. Omitting this parameter (i.e. calling Map#queryRenderedFeatures with zero arguments, or with only a  options argument) is equivalent to passing a bounding box encompassing the entire map viewport.
         * @param options Options object
         */
        queryRenderedFeatures(
            pointOrBox?: PointLike | [PointLike, PointLike],
            options?: { layers?: string[]; filter?: any[] } & FilterOptions,
        ): GeoJSONFeature[];

        /**
         * Returns an array of GeoJSON Feature objects representing features within the specified vector tile or GeoJSON source that satisfy the query parameters.
         *
         * In contrast to Map#queryRenderedFeatures, this function returns all features matching the query parameters, whether or not they are rendered by the current style (i.e. visible). The domain of the query includes all currently-loaded vector tiles and GeoJSON source tiles: this function does not check tiles outside the currently visible viewport.
         *
         * Because features come from tiled vector data or GeoJSON data that is converted to tiles internally, feature geometries may be split or duplicated across tile boundaries and, as a result, features may appear multiple times in query results. For example, suppose there is a highway running through the bounding rectangle of a query. The results of the query will be those parts of the highway that lie within the map tiles covering the bounding rectangle, even if the highway extends into other tiles, and the portion of the highway within each map tile will be returned as a separate feature. Similarly, a point feature near a tile boundary may appear in multiple tiles due to tile buffering.
         *
         * @param sourceID The ID of the vector tile or GeoJSON source to query.
         * @param parameters Parameters object
         */
        querySourceFeatures(
            sourceID: string,
            parameters?: {
                sourceLayer?: string;
                filter?: any[];
            } & FilterOptions,
        ): GeoJSONFeature[];

        setStyle(style: TrimbleMaps.Style | string, options?: { diff?: boolean; satelliteProvider?:typeof Common.SatelliteProvider[keyof typeof Common.SatelliteProvider]; localIdeographFontFamily?: string }): this;

        getStyle(): TrimbleMaps.Style;

        isStyleLoaded(): boolean;

        addSource(id: string, source: AnySourceData): this;

        isSourceLoaded(id: string): boolean;

        areTilesLoaded(): boolean;

        removeSource(id: string): this;

        getSource(id: string): AnySourceImpl;

        addImage(
            name: string,
            image:
                | HTMLImageElement
                | ArrayBufferView
                | { width: number; height: number; data: Uint8Array | Uint8ClampedArray }
                | ImageData
                | ImageBitmap,
            options?: { pixelRatio?: number; sdf?: boolean },
        ): this;

        hasImage(name: string): boolean;

        removeImage(name: string): this;

        loadImage(url: string, callback: Function): this;

        listImages(): string[];

        addLayer(layer: TrimbleMaps.AnyLayer, before?: string): this;

        moveLayer(id: string, beforeId?: string): this;

        removeLayer(id: string): this;

        getLayer(id: string): TrimbleMaps.AnyLayer;

        setFilter(layer: string, filter?: any[] | boolean | null, options?: FilterOptions | null): this;

        setLayerZoomRange(layerId: string, minzoom: number, maxzoom: number): this;

        getFilter(layer: string): any[];

        setPaintProperty(layer: string, name: string, value: any, klass?: string): this;

        getPaintProperty(layer: string, name: string): any;

        setLayoutProperty(layer: string, name: string, value: any): this;

        getLayoutProperty(layer: string, name: string): any;

        setLight(options: TrimbleMaps.Light, lightOptions?: any): this;

        getLight(): TrimbleMaps.Light;

        setFeatureState(
            feature: FeatureIdentifier | TrimbleMaps.GeoJSONFeature,
            state: { [key: string]: any },
        ): void;

        getFeatureState(feature: FeatureIdentifier | TrimbleMaps.GeoJSONFeature): { [key: string]: any };

        removeFeatureState(target: FeatureIdentifier | TrimbleMaps.GeoJSONFeature, key?: string): void;

        getContainer(): HTMLElement;

        getCanvasContainer(): HTMLElement;

        getCanvas(): HTMLCanvasElement;

        loaded(): boolean;

        remove(): void;

        triggerRepaint(): void;

        showTileBoundaries: boolean;

        showCollisionBoxes: boolean;

        /**
         * Gets and sets a Boolean indicating whether the map will visualize
         * the padding offsets.
         */
        showPadding: boolean;

        repaint: boolean;

        getCenter(): TrimbleMaps.LngLat;

        setCenter(center: LngLatLike, eventData?: TrimbleMaps.EventData): this;

        panBy(offset: PointLike, options?: TrimbleMaps.AnimationOptions, eventData?: TrimbleMaps.EventData): this;

        panTo(lnglat: LngLatLike, options?: TrimbleMaps.AnimationOptions, eventdata?: TrimbleMaps.EventData): this;

        getZoom(): number;

        setZoom(zoom: number, eventData?: TrimbleMaps.EventData): this;

        zoomTo(zoom: number, options?: TrimbleMaps.AnimationOptions, eventData?: TrimbleMaps.EventData): this;

        zoomIn(options?: TrimbleMaps.AnimationOptions, eventData?: TrimbleMaps.EventData): this;

        zoomOut(options?: TrimbleMaps.AnimationOptions, eventData?: TrimbleMaps.EventData): this;

        getBearing(): number;

        setBearing(bearing: number, eventData?: TrimbleMaps.EventData): this;

        /**
         * Returns the current padding applied around the map viewport.
         *
         * @returns The current padding around the map viewport.
         */
        getPadding(): PaddingOptions;

        /**
         * Sets the padding in pixels around the viewport.
         *
         * Equivalent to `jumpTo({padding: padding})`.
         *
         * @param padding The desired padding. Format: { left: number, right: number, top: number, bottom: number }
         * @param eventData Additional properties to be added to event objects of events triggered by this method.
         * @fires movestart
         * @fires moveend
         * @example
         * // Sets a left padding of 300px, and a top padding of 50px
         * map.setPadding({ left: 300, top: 50 });
         */
        setPadding(padding: PaddingOptions, eventData?: EventData): this;

        rotateTo(bearing: number, options?: TrimbleMaps.AnimationOptions, eventData?: EventData): this;

        resetNorth(options?: TrimbleMaps.AnimationOptions, eventData?: TrimbleMaps.EventData): this;

        resetNorthPitch(options?: TrimbleMaps.AnimationOptions | null, eventData?: TrimbleMaps.EventData | null): this;

        snapToNorth(options?: TrimbleMaps.AnimationOptions, eventData?: TrimbleMaps.EventData): this;

        getPitch(): number;

        setPitch(pitch: number, eventData?: EventData): this;

        cameraForBounds(bounds: LngLatBoundsLike, options?: CameraForBoundsOptions): CameraForBoundsResult | undefined;

        fitBounds(bounds: LngLatBoundsLike, options?: TrimbleMaps.FitBoundsOptions, eventData?: TrimbleMaps.EventData): this;

        fitScreenCoordinates(
            p0: PointLike,
            p1: PointLike,
            bearing: number,
            options?: AnimationOptions & CameraOptions,
            eventData?: EventData,
        ): this;

        jumpTo(options: TrimbleMaps.CameraOptions, eventData?: TrimbleMaps.EventData): this;

        easeTo(options: TrimbleMaps.EaseToOptions, eventData?: TrimbleMaps.EventData): this;

        flyTo(options: TrimbleMaps.FlyToOptions, eventData?: TrimbleMaps.EventData): this;

        isEasing(): boolean;

        stop(): this;

        on<T extends keyof MapLayerEventType>(
            type: T | string,
            layer: string,
            listener: (ev: MapLayerEventType[T] & EventData) => void,
        ): this;
        on<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & EventData) => void): this;
        on(type: string, listener: (ev: any) => void): this;

        once<T extends keyof MapLayerEventType>(
            type: T | string,
            layer: string,
            listener: (ev: MapLayerEventType[T] & EventData) => void,
        ): this;
        once<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & EventData) => void): this;
        once(type: string, listener: (ev: any) => void): this;

        off<T extends keyof MapLayerEventType>(
            type: T | string,
            layer: string,
            listener: (ev: MapLayerEventType[T] & EventData) => void,
        ): this;
        off<T extends keyof MapEventType>(type: T, listener: (ev: MapEventType[T] & EventData) => void): this;
        off(type: string, listener: (ev: any) => void): this;

        scrollZoom: ScrollZoomHandler;

        boxZoom: BoxZoomHandler;

        dragRotate: DragRotateHandler;

        dragPan: DragPanHandler;

        keyboard: KeyboardHandler;

        doubleClickZoom: DoubleClickZoomHandler;

        touchZoomRotate: TouchZoomRotateHandler;

        touchPitch: TouchPitchHandler;

        setRegion(region: typeof Common.Region[keyof typeof Common.Region]): this;
        getRegion(): string;

        /* @deprecated */
        setTrafficVisibility(isVisible: boolean): this;
        /* @deprecated */
        isTrafficVisible(): boolean;
        /* @deprecated */
        toggleTrafficVisibility(): this;

        /* @deprecated */
        setWeatherRadarVisibility(isVisible: boolean): this;
        /* @deprecated */
        isWeatherRadarVisible(): boolean;
        /* @deprecated */
        toggleWeatherRadarVisibility(): this;

        /* @deprecated */
        setWeatherCloudVisibility(isVisible: boolean): this;
        /* @deprecated */
        isWeatherCloudVisible(): boolean;
        /* @deprecated */
        toggleWeatherCloudVisibility(): this;

        /* @deprecated */
        setWeatherAlertVisibility(isVisible: boolean): this;
        /* @deprecated */
        isWeatherAlertVisible(): boolean;
        /* @deprecated */
        toggleWeatherAlertVisibility(): this;

        /* @deprecated */
        setRoadSurfaceVisibility(isVisible: boolean): this;
        /* @deprecated */
        isRoadSurfaceVisible(): boolean;
        /* @deprecated */
        toggleRoadSurfaceVisibility(): this;

        /* @deprecated */
        setPOIVisibility(isVisible: boolean): this;
        /* @deprecated */
        isPOIVisible(): boolean;
        /* @deprecated */
        togglePOIVisibility(): this;

        set3dBuildingVisibility(isVisible: boolean): this;
        is3dBuildingVisible(): boolean;
        toggle3dBuildingVisibility(): this;

        setPlacesVisibility(isVisible: boolean): this;
        isPlacesVisible(): boolean;
        togglePlacesVisibility(): this;

        /* @deprecated */
        setCustomRoadVisibility(isVisible: boolean): this;
        /* @deprecated */
        isCustomRoadVisible(): boolean;
        /* @deprecated */
        toggleCustomRoadVisibility(): this;

        setDarkMode(isVisible: boolean): this;

        setLanguage(language: string): void;

        readonly version: string;
    }

    export interface MapOptions {
        /**
         * If true, the gl context will be created with MSA antialiasing, which can be useful for antialiasing custom layers.
         * This is false by default as a performance optimization.
         */
        antialias?: boolean;

        /** If true, an attribution control will be added to the map. */
        attributionControl?: boolean;

        bearing?: number;

        /** Snap to north threshold in degrees. */
        bearingSnap?: number;

        /** The initial bounds of the map. If bounds is specified, it overrides center and zoom constructor options. */
        bounds?: LngLatBoundsLike;

        /** If true, enable the "box zoom" interaction (see BoxZoomHandler) */
        boxZoom?: boolean;

        /** initial map center */
        center?: LngLatLike;

        /**
         * The max number of pixels a user can shift the mouse pointer during a click for it to be
         * considered a valid click (as opposed to a mouse drag).
         *
         * @default 3
         */
        clickTolerance?: number;

        /**
         * If `true`, Resource Timing API information will be collected for requests made by GeoJSON
         * and Vector Tile web workers (this information is normally inaccessible from the main
         * Javascript thread). Information will be returned in a `resourceTiming` property of
         * relevant `data` events.
         *
         * @default false
         */
        collectResourceTiming?: boolean;

        /**
         * If `true`, symbols from multiple sources can collide with each other during collision
         * detection. If `false`, collision detection is run separately for the symbols in each source.
         *
         * @default true
         */
        crossSourceCollisions?: boolean;

        /** ID of the container element */
        container: string | HTMLElement;

        /**
         * String or strings to show in an AttributionControl.
         * Only applicable if options.attributionControl is `true`.
         */
        customAttribution?: string | string[];

        /**
         * If true, enable the "drag to pan" interaction (see DragPanHandler).
         */
        dragPan?: boolean;

        /**
         * If true, enable the "drag to rotate" interaction (see DragRotateHandler).
         */
        dragRotate?: boolean;

        /**
         * If true, enable the "double click to zoom" interaction (see DoubleClickZoomHandler).
         */
        doubleClickZoom?: boolean;

        /**
         * If `true`, the map's position (zoom, center latitude, center longitude, bearing, and pitch) will be synced with the hash fragment of the page's URL.
         * For example, `http://path/to/my/page.html#2.59/39.26/53.07/-24.1/60`.
         * An additional string may optionally be provided to indicate a parameter-styled hash,
         * e.g. http://path/to/my/page.html#map=2.59/39.26/53.07/-24.1/60&foo=bar, where foo
         * is a custom parameter and bar is an arbitrary hash distinct from the map hash.
         */
        hash?: boolean | string;

        /**
         * Controls the duration of the fade-in/fade-out animation for label collisions, in milliseconds.
         * This setting affects all symbol layers. This setting does not affect the duration of runtime
         * styling transitions or raster tile cross-fading.
         *
         * @default 300
         */
        fadeDuration?: number;

        /**
         * If true, map creation will fail if the implementation determines that the performance of the created WebGL context would be dramatically lower than expected.
         */
        failIfMajorPerformanceCaveat?: boolean;

        /**
         * A fitBounds options object to use only when setting the bounds option.
         */
        fitBoundsOptions?: FitBoundsOptions;

        /**
         * If false, no mouse, touch, or keyboard listeners are attached to the map, so it will not respond to input
         */
        interactive?: boolean;

        /**
         * If true, enable keyboard shortcuts (see KeyboardHandler).
         */
        keyboard?: boolean;

        /**
         * A patch to apply to the default localization table for UI strings, e.g. control tooltips.
         * The `locale` object maps namespaced UI string IDs to translated strings in the target language;
         * see `src/ui/default_locale.js` for an example with all supported string IDs.
         * The object may specify all UI strings (thereby adding support for a new translation) or
         * only a subset of strings (thereby patching the default translation table).
         */
        locale?: { [key: string]: string };

        /**
         * If specified, defines a CSS font-family for locally overriding generation of glyphs in the
         * 'CJK Unified Ideographs' and 'Hangul Syllables' ranges. In these ranges, font settings from
         * the map's style will be ignored, except for font-weight keywords (light/regular/medium/bold).
         * The purpose of this option is to avoid bandwidth-intensive glyph server requests.
         *
         * @default null
         */
        localIdeographFontFamily?: string;

        /**
         * A string representing the position of the wordmark on the map.
         *
         * @default "bottom-left"
         */
        logoPosition?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right';

        /**
         * If set, the map is constrained to the given bounds.
         */
        maxBounds?: LngLatBoundsLike;

        /**
         * Maximum pitch of the map.
         */
        maxPitch?: number;

        /** Maximum zoom of the map. */
        maxZoom?: number;

        /** Minimum pitch of the map. */
        minPitch?: number;

        /** Minimum zoom of the map. */
        minZoom?: number;

        /** If true, The maps canvas can be exported to a PNG using map.getCanvas().toDataURL();. This is false by default as a performance optimization. */
        preserveDrawingBuffer?: boolean;

        /**
         * The initial pitch (tilt) of the map, measured in degrees away from the plane of the
         * screen (0-60).
         *
         * @default 0
         */
        pitch?: number;

        /**
         * If `false`, the map's pitch (tilt) control with "drag to rotate" interaction will be disabled.
         *
         * @default true
         */
        pitchWithRotate?: boolean;

        /**
         * If `false`, the map won't attempt to re-request tiles once they expire per their HTTP
         * `cacheControl`/`expires` headers.
         *
         * @default true
         */
        refreshExpiredTiles?: boolean;

        /**
         * If `true`, multiple copies of the world will be rendered, when zoomed out.
         *
         * @default true
         */
        renderWorldCopies?: boolean;

        /** If true, enable the "scroll to zoom" interaction */
        scrollZoom?: boolean;

        /** Style value from TrimbleMaps.Common.Style ex. TrimbleMaps.Common.Style.SATELLITE */
        style?: typeof Common.Style[keyof typeof Common.Style];

        /** If  true, the map will automatically resize when the browser window resizes */
        trackResize?: boolean;

        /**
         * A callback run before the Map makes a request for an external URL. The callback can be
         * used to modify the url, set headers, or set the credentials property for cross-origin requests.
         *
         * @default null
         */
        transformRequest?: TransformRequestFunction;

        /** If true, enable the "pinch to rotate and zoom" interaction (see TouchZoomRotateHandler). */
        touchZoomRotate?: boolean;

        /** If true, the "drag to pitch" interaction is enabled */
        touchPitch?: boolean;

        /** Initial zoom level */
        zoom?: number;

        /**
         * The maximum number of tiles stored in the tile cache for a given source. If omitted, the
         * cache will be dynamically sized based on the current viewport.
         *
         * @default null
         */
        maxTileCacheSize?: number;

        /** The map's region. ex. TrimbleMaps.Common.Region.NA */
        region?: typeof Common.Region[keyof typeof Common.Region];

        /** The language used for map labels. ex. TrimbleMaps.Common.Language.EN */
        language?: typeof Common.Language[keyof typeof Common.Language];

        /** The Satellite Provider for Satellite Styles ex. TrimbleMaps.Common.SatelliteProvider.Sat1 */
        satelliteProvider?: typeof Common.SatelliteProvider[keyof typeof Common.SatelliteProvider];
    }

    export type ResourceType =
        | 'Unknown'
        | 'Style'
        | 'Source'
        | 'Tile'
        | 'Glyphs'
        | 'SpriteImage'
        | 'SpriteJSON'
        | 'Image';

    export interface RequestParameters {
        /**
         * The URL to be requested.
         */
        url: string;

        /**
         * Use `'include'` to send cookies with cross-origin requests.
         */
        credentials?: 'same-origin' | 'include';

        /**
         * The headers to be sent with the request.
         */
        headers?: { [header: string]: any };

        method?: 'GET' | 'POST' | 'PUT';

        collectResourceTiming?: boolean;
    }

    export type TransformRequestFunction = (url: string, resourceType: ResourceType) => RequestParameters;

    export interface PaddingOptions {
        top: number;
        bottom: number;
        left: number;
        right: number;
    }

    export interface FeatureIdentifier {
        id?: string | number;
        source: string;
        sourceLayer?: string;
    }

    /**
     * BoxZoomHandler
     */
    export class BoxZoomHandler {
        constructor(map: TrimbleMaps.Map);

        isEnabled(): boolean;

        isActive(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * ScrollZoomHandler
     */
    export class ScrollZoomHandler {
        constructor(map: TrimbleMaps.Map);

        isEnabled(): boolean;

        enable(): void;

        disable(): void;

        setZoomRate(zoomRate: number): void;

        setWheelZoomRate(wheelZoomRate: number): void;
    }

    /**
     * DragPenHandler
     */
    export class DragPanHandler {
        constructor(map: TrimbleMaps.Map);

        isEnabled(): boolean;

        isActive(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * DragRotateHandler
     */
    export class DragRotateHandler {
        constructor(map: TrimbleMaps.Map, options?: { bearingSnap?: number; pitchWithRotate?: boolean });

        isEnabled(): boolean;

        isActive(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * KeyboardHandler
     */
    export class KeyboardHandler {
        constructor(map: TrimbleMaps.Map);

        isEnabled(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * DoubleClickZoomHandler
     */
    export class DoubleClickZoomHandler {
        constructor(map: TrimbleMaps.Map);

        isEnabled(): boolean;

        enable(): void;

        disable(): void;
    }

    /**
     * TouchZoomRotateHandler
     */
    export class TouchZoomRotateHandler {
        constructor(map: TrimbleMaps.Map);

        isEnabled(): boolean;

        enable(): void;

        disable(): void;

        disableRotation(): void;

        enableRotation(): void;
    }

    export class TouchPitchHandler {
        constructor(map: TrimbleMaps.Map);

        enable(): void;

        isActive(): boolean;

        isEnabled(): boolean;

        disable(): void;
    }

    export interface IControl {
        onAdd(map: Map): HTMLElement;

        onRemove(map?: Map): void;

        getDefaultPosition?(): string;
    }

    /**
     * Control
     */
    export class Control extends Evented implements IControl {
        onAdd(map: Map): HTMLElement;
        onRemove(): void;
        getDefaultPosition?(): string;
    }

    /**
     * Navigation
     */
    export class NavigationControl extends Control {
        constructor(options?: { showCompass?: boolean; showZoom?: boolean; visualizePitch?: boolean });
    }

    export class PositionOptions {
        enableHighAccuracy?: boolean;
        timeout?: number;
        maximumAge?: number;
    }

    /**
     * Geolocate
     */
    export class GeolocateControl extends Control {
        constructor(options?: {
            positionOptions?: PositionOptions;
            fitBoundsOptions?: FitBoundsOptions;
            trackUserLocation?: boolean;
            showAccuracyCircle?: boolean;
            showUserLocation?: boolean;
        });
        trigger(): boolean;
    }

    /**
     * Attribution
     */
    export class AttributionControl extends Control {
        constructor(options?: { compact?: boolean; customAttribution?: string | string[] });
    }

    /**
     * Scale
     */
    export class ScaleControl extends Control {
        constructor(options?: { maxWidth?: number; unit?: string });

        setUnit(unit: 'imperial' | 'metric' | 'nautical'): void;
        getDefaultPosition(): string;
    }

    /**
     * FullscreenControl
     */
    export class FullscreenControl extends Control {
        constructor(options?: FullscreenControlOptions | null);
    }

    export interface FullscreenControlOptions {
        /**
         * A compatible DOM element which should be made full screen.
         * By default, the map container element will be made full screen.
         */
        container?: HTMLElement | null;
    }

    /**
     * Popup
     */
    export class Popup extends Evented {
        constructor(options?: TrimbleMaps.PopupOptions);

        addTo(map: TrimbleMaps.Map): this;

        isOpen(): boolean;

        remove(): this;

        getLngLat(): TrimbleMaps.LngLat;

        /**
         * Sets the geographical location of the popup's anchor, and moves the popup to it. Replaces trackPointer() behavior.
         *
         * @param lnglat The geographical location to set as the popup's anchor.
         */
        setLngLat(lnglat: LngLatLike): this;

        /**
         * Tracks the popup anchor to the cursor position, on screens with a pointer device (will be hidden on touchscreens). Replaces the setLngLat behavior.
         * For most use cases, `closeOnClick` and `closeButton` should also be set to `false` here.
         */
        trackPointer(): this;

        /** Returns the `Popup`'s HTML element. */
        getElement(): HTMLElement;

        setText(text: string): this;

        setHTML(html: string): this;

        setDOMContent(htmlNode: Node): this;

        getMaxWidth(): string;

        setMaxWidth(maxWidth: string): this;

        /**
         * Adds a CSS class to the popup container element.
         *
         * @param className Non-empty string with CSS class name to add to popup container
         *
         * @example
         * let popup = new TrimbleMaps.Popup()
         * popup.addClassName('some-class')
         */
        addClassName(className: string): void;

        /**
         * Removes a CSS class from the popup container element.
         *
         * @param className Non-empty string with CSS class name to remove from popup container
         *
         * @example
         * let popup = new TrimbleMaps.Popup()
         * popup.removeClassName('some-class')
         */
        removeClassName(className: string): void;

        /**
         * Add or remove the given CSS class on the popup container, depending on whether the container currently has that class.
         *
         * @param className Non-empty string with CSS class name to add/remove
         *
         * @returns if the class was removed return false, if class was added, then return true
         *
         * @example
         * let popup = new TrimbleMaps.Popup()
         * popup.toggleClassName('toggleClass')
         */
        toggleClassName(className: string): void;
    }

    export interface PopupOptions {
        closeButton?: boolean;

        closeOnClick?: boolean;

        /**
         * @param [options.closeOnMove=false] If `true`, the popup will closed when the map moves.
         */
        closeOnMove?: boolean;

        anchor?: Anchor;

        offset?: number | PointLike | { [key: string]: PointLike };

        className?: string;

        maxWidth?: string;
    }

    export interface Style {
        bearing?: number;
        center?: number[];
        glyphs?: string;
        layers?: AnyLayer[];
        metadata?: any;
        name?: string;
        pitch?: number;
        light?: Light;
        sources?: Sources;
        sprite?: string;
        transition?: Transition;
        version: number;
        zoom?: number;
    }

    export interface Transition {
        delay?: number;
        duration?: number;
    }

    export interface Light {
        anchor?: 'map' | 'viewport';
        position?: number[];
        'position-transition'?: Transition;
        color?: string;
        'color-transition'?: Transition;
        intensity?: number;
        'intensity-transition'?: Transition;
    }

    export interface Sources {
        [sourceName: string]: AnySourceData;
    }

    export type PromoteIdSpecification = { [key: string]: string } | string;

    export type AnySourceData =
        | GeoJSONSourceRaw
        | VideoSourceRaw
        | ImageSourceRaw
        | CanvasSourceRaw
        | VectorSource
        | RasterSource
        | RasterDemSource;

    interface VectorSourceImpl extends VectorSource {
        /**
         * Sets the source `tiles` property and re-renders the map.
         *
         * @param tiles An array of one or more tile source URLs, as in the TileJSON spec.
         * @returns this
         */
        setTiles(tiles: ReadonlyArray<string>): VectorSourceImpl;

        /**
         * Sets the source `url` property and re-renders the map.
         *
         * @param url A URL to a TileJSON resource. Supported protocols are `http:` and `https:`.
         * @returns this
         */
        setUrl(url: string): VectorSourceImpl;
    }

    export type AnySourceImpl =
        | GeoJSONSource
        | VideoSource
        | ImageSource
        | CanvasSource
        | VectorSourceImpl
        | RasterSource
        | RasterDemSource;

    export interface Source {
        type: 'vector' | 'raster' | 'raster-dem' | 'geojson' | 'image' | 'video' | 'canvas';
    }

    /**
     * GeoJSONSource
     */

    export interface GeoJSONSourceRaw extends Source, GeoJSONSourceOptions {
        type: 'geojson';
    }

    export class GeoJSONSource implements GeoJSONSourceRaw {
        type: 'geojson';

        constructor(options?: TrimbleMaps.GeoJSONSourceOptions);

        setData(data: GeoJSON.Feature<GeoJSON.Geometry> | GeoJSON.FeatureCollection<GeoJSON.Geometry> | String): this;

        getClusterExpansionZoom(clusterId: number, callback: (error: any, zoom: number) => void): this;

        getClusterChildren(
            clusterId: number,
            callback: (error: any, features: GeoJSON.Feature<GeoJSON.Geometry>[]) => void,
        ): this;

        getClusterLeaves(
            cluserId: number,
            limit: number,
            offset: number,
            callback: (error: any, features: GeoJSON.Feature<GeoJSON.Geometry>[]) => void,
        ): this;
    }

    export interface GeoJSONSourceOptions {
        data?: GeoJSON.Feature<GeoJSON.Geometry> | GeoJSON.FeatureCollection<GeoJSON.Geometry> | string;

        maxzoom?: number;

        attribution?: string;

        buffer?: number;

        tolerance?: number;

        cluster?: number | boolean;

        clusterRadius?: number;

        clusterMaxZoom?: number;

        /**
         * Minimum number of points necessary to form a cluster if clustering is enabled. Defaults to `2`.
         */
        clusterMinPoints?: number;

        clusterProperties?: object;

        lineMetrics?: boolean;

        generateId?: boolean;

        promoteId?: PromoteIdSpecification;

        filter?: any;
    }

    /**
     * VideoSource
     */
    export interface VideoSourceRaw extends Source, VideoSourceOptions {
        type: 'video';
    }

    export class VideoSource implements VideoSourceRaw {
        type: 'video';

        constructor(options?: TrimbleMaps.VideoSourceOptions);

        getVideo(): HTMLVideoElement;

        setCoordinates(coordinates: number[][]): this;
    }

    export interface VideoSourceOptions {
        urls?: string[];

        coordinates?: number[][];
    }

    /**
     * ImageSource
     */
    export interface ImageSourceRaw extends Source, ImageSourceOptions {
        type: 'image';
    }

    export class ImageSource implements ImageSourceRaw {
        type: 'image';

        constructor(options?: TrimbleMaps.ImageSourceOptions);

        updateImage(options: ImageSourceOptions): this;

        setCoordinates(coordinates: number[][]): this;
    }

    export interface ImageSourceOptions {
        url?: string;

        coordinates?: number[][];
    }

    /**
     * CanvasSource
     */
    export interface CanvasSourceRaw extends Source, CanvasSourceOptions {
        type: 'canvas';
    }

    export class CanvasSource implements CanvasSourceRaw {
        type: 'canvas';

        coordinates: number[][];

        canvas: string | HTMLCanvasElement;

        play(): void;

        pause(): void;

        getCanvas(): HTMLCanvasElement;

        setCoordinates(coordinates: number[][]): this;
    }

    export interface CanvasSourceOptions {
        coordinates: number[][];

        animate?: boolean;

        canvas: string | HTMLCanvasElement;
    }

    interface VectorSource extends Source {
        type: 'vector';
        url?: string;
        tiles?: string[];
        bounds?: number[];
        scheme?: 'xyz' | 'tms';
        minzoom?: number;
        maxzoom?: number;
        attribution?: string;
        promoteId?: PromoteIdSpecification;
    }

    interface RasterSource extends Source {
        type: 'raster';
        url?: string;
        tiles?: string[];
        bounds?: number[];
        minzoom?: number;
        maxzoom?: number;
        tileSize?: number;
        scheme?: 'xyz' | 'tms';
        attribution?: string;
    }

    interface RasterDemSource extends Source {
        type: 'raster-dem';
        url?: string;
        tiles?: string[];
        bounds?: number[];
        minzoom?: number;
        maxzoom?: number;
        tileSize?: number;
        attribution?: string;
        encoding?: 'terrarium' | 'mapbox';
    }

    /**
     * LngLat
     */
    export class LngLat {
        lng: number;
        lat: number;

        constructor(lng: number, lat: number);

        /** Return a new LngLat object whose longitude is wrapped to the range (-180, 180). */
        wrap(): TrimbleMaps.LngLat;

        /** Return a LngLat as an array */
        toArray(): number[];

        /** Return a LngLat as a string */
        toString(): string;

        /**
         * Returns the approximate distance between a pair of coordinates in meters
         * Uses the Haversine Formula (from R.W. Sinnott, "Virtues of the Haversine", Sky and Telescope, vol. 68, no. 2, 1984, p. 159)
         */
        distanceTo(lngLat: LngLat): number;

        toBounds(radius: number): LngLatBounds;

        static convert(input: LngLatLike): TrimbleMaps.LngLat;
    }

    /**
     * LngLatBounds
     */
    export class LngLatBounds {
        sw: LngLatLike;
        ne: LngLatLike;

        constructor(boundsLike?: [LngLatLike, LngLatLike] | [number, number, number, number]);
        constructor(sw: LngLatLike, ne: LngLatLike);

        setNorthEast(ne: LngLatLike): this;

        setSouthWest(sw: LngLatLike): this;

        /** Check if the point is within the bounding box. */
        contains(lnglat: LngLatLike): boolean;

        /** Extend the bounds to include a given LngLat or LngLatBounds. */
        extend(obj: TrimbleMaps.LngLatLike | TrimbleMaps.LngLatBoundsLike): this;

        /** Get the point equidistant from this box's corners */
        getCenter(): TrimbleMaps.LngLat;

        /** Get southwest corner */
        getSouthWest(): TrimbleMaps.LngLat;

        /** Get northeast corner */
        getNorthEast(): TrimbleMaps.LngLat;

        /** Get northwest corner */
        getNorthWest(): TrimbleMaps.LngLat;

        /** Get southeast corner */
        getSouthEast(): TrimbleMaps.LngLat;

        /** Get west edge longitude */
        getWest(): number;

        /** Get south edge latitude */
        getSouth(): number;

        /** Get east edge longitude */
        getEast(): number;

        /** Get north edge latitude */
        getNorth(): number;

        /** Returns a LngLatBounds as an array */
        toArray(): number[][];

        /** Return a LngLatBounds as a string */
        toString(): string;

        /** Returns a boolean */
        isEmpty(): boolean;

        /** Convert an array to a LngLatBounds object, or return an existing LngLatBounds object unchanged. */
        static convert(input: LngLatBoundsLike): TrimbleMaps.LngLatBounds;
    }

    /**
     * Point
     */
    // Todo: Pull out class to seperate definition for Module "point-geometry"
    export class Point {
        x: number;
        y: number;

        constructor(x: number, y: number);

        clone(): Point;

        add(p: Point): Point;

        sub(p: Point): Point;

        mult(k: number): Point;

        div(k: number): Point;

        rotate(a: number): Point;

        matMult(m: number): Point;

        unit(): Point;

        perp(): Point;

        round(): Point;

        mag(): number;

        equals(p: Point): boolean;

        dist(p: Point): number;

        distSqr(p: Point): number;

        angle(): number;

        angleTo(p: Point): number;

        angleWidth(p: Point): number;

        angleWithSep(x: number, y: number): number;

        static convert(a: PointLike): Point;
    }

    /**
     * MercatorCoordinate
     */
    export class MercatorCoordinate {
        /** The x component of the position. */
        x: number;

        /** The y component of the position. */
        y: number;

        /**
         * The z component of the position.
         *
         * @default 0
         */
        z?: number;

        constructor(x: number, y: number, z?: number);

        /** Returns the altitude in meters of the coordinate. */
        toAltitude(): number;

        /** Returns the LngLat for the coordinate. */
        toLngLat(): LngLat;

        /**
         * Returns the distance of 1 meter in MercatorCoordinate units at this latitude.
         *
         * For coordinates in real world units using meters, this naturally provides the
         * scale to transform into MercatorCoordinates.
         */
        meterInMercatorCoordinateUnits(): number;

        /** Project a LngLat to a MercatorCoordinate. */
        static fromLngLat(lngLatLike: LngLatLike, altitude?: number): MercatorCoordinate;
    }

    /**
     * Marker
     */
    export class Marker extends Evented {
        constructor(options?: TrimbleMaps.MarkerOptions);

        constructor(element?: HTMLElement, options?: TrimbleMaps.MarkerOptions);

        addTo(map: Map): this;

        remove(): this;

        getLngLat(): LngLat;

        setLngLat(lngLat: LngLatLike): this;

        getElement(): HTMLElement;

        setPopup(popup?: Popup): this;

        getPopup(): Popup;

        togglePopup(): this;

        getOffset(): PointLike;

        setOffset(offset: PointLike): this;

        setDraggable(shouldBeDraggable: boolean): this;

        isDraggable(): boolean;

        getRotationAlignment(): Alignment;

        setRotationAlignment(alignment: Alignment): this;

        getPitchAlignment(): Alignment;

        setPitchAlignment(alignment: Alignment): this;
    }

    type Alignment = 'map' | 'viewport' | 'auto';

    export interface MarkerOptions {
        /** DOM element to use as a marker. The default is a light blue, droplet-shaped SVG marker */
        element?: HTMLElement;

        /** The offset in pixels as a PointLike object to apply relative to the element's center. Negatives indicate left and up. */
        offset?: PointLike;

        /**
         * A string indicating the part of the Marker that should be positioned closest to the coordinate set via Marker.setLngLat.
         * Options are `'center'`, `'top'`, `'bottom'`, `'left'`, `'right'`, `'top-left'`, `'top-right'`, `'bottom-left'`, and `'bottom-right'`.
         * The default value os `'center'`
         */
        anchor?: Anchor;

        /**
         * The color to use for the default marker if options.element is not provided. The default is light blue (#3FB1CE).
         */
        color?: string;

        /**
         * A boolean indicating whether or not a marker is able to be dragged to a new position on the map. The default value is false
         */
        draggable?: boolean;

        /**
         * The rotation angle of the marker in degrees, relative to its `rotationAlignment` setting. A positive value will rotate the marker clockwise.
         * The default value is 0.
         */
        rotation?: number;

        /**
         * `map` aligns the `Marker`'s rotation relative to the map, maintaining a bearing as the map rotates.
         * `viewport` aligns the `Marker`'s rotation relative to the viewport, agnostic to map rotations.
         * `auto` is equivalent to `viewport`.
         * The default value is `auto`
         */
        rotationAlignment?: Alignment;

        /**
         * `map` aligns the `Marker` to the plane of the map.
         * `viewport` aligns the `Marker` to the plane of the viewport.
         * `auto` automatically matches the value of `rotationAlignment`.
         * The default value is `auto`.
         */
        pitchAlignment?: Alignment;

        /**
         * The scale to use for the default marker if options.element is not provided.
         * The default scale (1) corresponds to a height of `41px` and a width of `27px`.
         */
        scale?: number;
    }

    /**
     * Evented
     */
    export class Evented {
        on(type: string, listener: Function): this;

        off(type?: string | any, listener?: Function): this;

        once(type: string, listener: Function): this;

        fire(type: string, properties?: { [key: string]: any }): this;
    }

    /**
     * StyleOptions
     */
    export interface StyleOptions {
        transition?: boolean;
    }

    export type GeoJSONFeature = GeoJSON.Feature<GeoJSON.Geometry> & {
        layer: Layer;
        source: string;
        sourceLayer: string;
        state: { [key: string]: any };
    };

    export type EventData = { [key: string]: any };

    export class MapEvent<TOrig = undefined> {
        type: string;
        target: Map;
        originalEvent: TOrig;
    }

    export class MapMouseEvent extends MapEvent<MouseEvent> {
        type:
            | 'mousedown'
            | 'mouseup'
            | 'click'
            | 'dblclick'
            | 'mousemove'
            | 'mouseover'
            | 'mouseenter'
            | 'mouseleave'
            | 'mouseout'
            | 'contextmenu';

        point: Point;
        lngLat: LngLat;

        preventDefault(): void;
        defaultPrevented: boolean;
    }

    export type MapLayerMouseEvent = MapMouseEvent & { features?: GeoJSONFeature[] };

    export class MapTouchEvent extends MapEvent<TouchEvent> {
        type: 'touchstart' | 'touchend' | 'touchcancel';

        point: Point;
        lngLat: LngLat;
        points: Point[];
        lngLats: LngLat[];

        preventDefault(): void;
        defaultPrevented: boolean;
    }

    export type MapLayerTouchEvent = MapTouchEvent & { features?: GeoJSONFeature[] };

    export class MapWheelEvent extends MapEvent<WheelEvent> {
        type: 'wheel';

        preventDefault(): void;
        defaultPrevented: boolean;
    }

    export class ContentVisibilityEvent extends Event {
      id: string;
      isVisible: boolean;
    }

    export class ContentRemoveEvent extends Event {
      id: string;
    }
    
    export class ContentAddEvent extends Event {
        id: string;
    }

    export interface MapBoxZoomEvent extends MapEvent<MouseEvent> {
        type: 'boxzoomstart' | 'boxzoomend' | 'boxzoomcancel';

        boxZoomBounds: LngLatBounds;
    }

    export type MapDataEvent = MapSourceDataEvent | MapStyleDataEvent;

    export interface MapStyleDataEvent extends MapEvent {
        dataType: 'style';
    }

    export interface MapSourceDataEvent extends MapEvent {
        dataType: 'source';
        isSourceLoaded: boolean;
        source: Source;
        sourceId: string;
        sourceDataType: 'metadata' | 'content';
        tile: any;
        coord: Coordinate;
    }

    export interface MapStyleChangeEvent extends MapEvent {
        type: 'stylechanging' | 'stylechange',
        previousStyleName?: string;
        styleName: string;
    }

    export interface Coordinate {
        canonical: CanonicalCoordinate;
        wrap: number;
        key: number;
    }

    export interface CanonicalCoordinate {
        x: number;
        y: number;
        z: number;
        key: number;
        equals(coord: CanonicalCoordinate): boolean;
    }

    export interface MapContextEvent extends MapEvent<WebGLContextEvent> {
        type: 'webglcontextlost' | 'webglcontextrestored';
    }

    export class ErrorEvent extends MapEvent {
        type: 'error';
        error: Error;
    }

    /**
     * FilterOptions
     */
    export interface FilterOptions {
        /**
         * Whether to check if the filter conforms to the Style Specification.
         * Disabling validation is a performance optimization that should only be used
         * if you have previously validated the values you will be passing to this function.
         */
        validate?: boolean | null;
    }

    /**
     * AnimationOptions
     */
    export interface AnimationOptions {
        /** Number in milliseconds */
        duration?: number;
        /**
         * A function taking a time in the range 0..1 and returning a number where 0 is the initial
         * state and 1 is the final state.
         */
        easing?: (time: number) => number;
        /** point, origin of movement relative to map center */
        offset?: PointLike;
        /** When set to false, no animation happens */
        animate?: boolean;

        /**
         * If `true`, then the animation is considered essential and will not be affected by `prefers-reduced-motion`.
         * Otherwise, the transition will happen instantly if the user has enabled the `reduced motion` accesibility feature in their operating system.
         */
        essential?: boolean;
    }

    /**
     * CameraOptions
     */
    export interface CameraOptions {
        /** Map center */
        center?: LngLatLike;
        /** Map zoom level */
        zoom?: number;
        /** Map rotation bearing in degrees counter-clockwise from north */
        bearing?: number;
        /** Map angle in degrees at which the camera is looking at the ground */
        pitch?: number;
        /** If zooming, the zoom center (defaults to map center) */
        around?: LngLatLike;
    }

    export interface CameraForBoundsOptions extends CameraOptions {
        padding?: number | PaddingOptions;
        offset?: PointLike;
        maxZoom?: number;
    }

    // The docs say that if the result is defined, it will have zoom, center and bearing set.
    // In practice center is always a {lat, lng} object.
    export type CameraForBoundsResult = Required<Pick<CameraOptions, 'zoom' | 'bearing'>> & {
        /** Map center */
        center: { lng: number; lat: number };
    };

    /**
     * FlyToOptions
     */
    export interface FlyToOptions extends AnimationOptions, CameraOptions {
        curve?: number;
        minZoom?: number;
        speed?: number;
        screenSpeed?: number;
        maxDuration?: number;
    }

    /**
     * EaseToOptions
     */
    export interface EaseToOptions extends AnimationOptions, CameraOptions {
        delayEndEvents?: number;
    }

    export interface FitBoundsOptions extends TrimbleMaps.FlyToOptions {
        linear?: boolean;
        padding?: number | TrimbleMaps.PaddingOptions;
        offset?: TrimbleMaps.PointLike;
        maxZoom?: number;
        maxDuration?: number;
    }

    /**
     * MapEvent
     */
    export type MapEventType = {
        error: ErrorEvent;

        load: MapEvent;
        idle: MapEvent;
        remove: MapEvent;
        render: MapEvent;
        resize: MapEvent;

        webglcontextlost: MapContextEvent;
        webglcontextrestored: MapContextEvent;

        dataloading: MapDataEvent;
        data: MapDataEvent;
        tiledataloading: MapDataEvent;
        sourcedataloading: MapSourceDataEvent;
        styledataloading: MapStyleDataEvent;
        sourcedata: MapSourceDataEvent;
        styledata: MapStyleDataEvent;

        styleChanging: MapStyleChangeEvent;
        styleChange: MapStyleChangeEvent;

        boxzoomcancel: MapBoxZoomEvent;
        boxzoomstart: MapBoxZoomEvent;
        boxzoomend: MapBoxZoomEvent;

        touchcancel: MapTouchEvent;
        touchmove: MapTouchEvent;
        touchend: MapTouchEvent;
        touchstart: MapTouchEvent;

        click: MapMouseEvent;
        contextmenu: MapMouseEvent;
        dblclick: MapMouseEvent;
        mousemove: MapMouseEvent;
        mouseup: MapMouseEvent;
        mousedown: MapMouseEvent;
        mouseout: MapMouseEvent;
        mouseover: MapMouseEvent;

        movestart: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        move: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        moveend: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;

        zoomstart: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        zoom: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;
        zoomend: MapEvent<MouseEvent | TouchEvent | WheelEvent | undefined>;

        rotatestart: MapEvent<MouseEvent | TouchEvent | undefined>;
        rotate: MapEvent<MouseEvent | TouchEvent | undefined>;
        rotateend: MapEvent<MouseEvent | TouchEvent | undefined>;

        dragstart: MapEvent<MouseEvent | TouchEvent | undefined>;
        drag: MapEvent<MouseEvent | TouchEvent | undefined>;
        dragend: MapEvent<MouseEvent | TouchEvent | undefined>;

        pitchstart: MapEvent<MouseEvent | TouchEvent | undefined>;
        pitch: MapEvent<MouseEvent | TouchEvent | undefined>;
        pitchend: MapEvent<MouseEvent | TouchEvent | undefined>;

        wheel: MapWheelEvent;
    };

    export type MapLayerEventType = {
        click: MapLayerMouseEvent;
        dblclick: MapLayerMouseEvent;
        mousedown: MapLayerMouseEvent;
        mouseup: MapLayerMouseEvent;
        mousemove: MapLayerMouseEvent;
        mouseenter: MapLayerMouseEvent;
        mouseleave: MapLayerMouseEvent;
        mouseover: MapLayerMouseEvent;
        mouseout: MapLayerMouseEvent;
        contextmenu: MapLayerMouseEvent;

        touchstart: MapLayerTouchEvent;
        touchend: MapLayerTouchEvent;
        touchcancel: MapLayerTouchEvent;
    };

    export type AnyLayout =
        | BackgroundLayout
        | FillLayout
        | FillExtrusionLayout
        | LineLayout
        | SymbolLayout
        | RasterLayout
        | CircleLayout
        | HeatmapLayout
        | HillshadeLayout;

    export type AnyPaint =
        | BackgroundPaint
        | FillPaint
        | FillExtrusionPaint
        | LinePaint
        | SymbolPaint
        | RasterPaint
        | CirclePaint
        | HeatmapPaint
        | HillshadePaint;

    interface Layer {
        id: string;
        type: string;

        metadata?: any;
        ref?: string;

        source?: string | AnySourceData;

        'source-layer'?: string;

        minzoom?: number;
        maxzoom?: number;

        interactive?: boolean;

        filter?: any[];
        layout?: Layout;
        paint?: object;
    }

    interface BackgroundLayer extends Layer {
        type: 'background';
        layout?: BackgroundLayout;
        paint?: BackgroundPaint;
    }

    interface CircleLayer extends Layer {
        type: 'circle';
        layout?: CircleLayout;
        paint?: CirclePaint;
    }

    interface FillExtrusionLayer extends Layer {
        type: 'fill-extrusion';
        layout?: FillExtrusionLayout;
        paint?: FillExtrusionPaint;
    }

    interface FillLayer extends Layer {
        type: 'fill';
        layout?: FillLayout;
        paint?: FillPaint;
    }

    interface HeatmapLayer extends Layer {
        type: 'heatmap';
        layout?: HeatmapLayout;
        paint?: HeatmapPaint;
    }

    interface HillshadeLayer extends Layer {
        type: 'hillshade';
        layout?: HillshadeLayout;
        paint?: HillshadePaint;
    }

    interface LineLayer extends Layer {
        type: 'line';
        layout?: LineLayout;
        paint?: LinePaint;
    }

    interface RasterLayer extends Layer {
        type: 'raster';
        layout?: RasterLayout;
        paint?: RasterPaint;
    }

    interface SymbolLayer extends Layer {
        type: 'symbol';
        layout?: SymbolLayout;
        paint?: SymbolPaint;
    }

    export type AnyLayer =
        | BackgroundLayer
        | CircleLayer
        | FillExtrusionLayer
        | FillLayer
        | HeatmapLayer
        | HillshadeLayer
        | LineLayer
        | RasterLayer
        | SymbolLayer
        | CustomLayerInterface;

    export interface CustomLayerInterface {
        /** A unique layer id. */
        id: string;

        /* The layer's type. Must be "custom". */
        type: 'custom';

        /* Either "2d" or "3d". Defaults to  "2d". */
        renderingMode?: '2d' | '3d';

        /**
         * Optional method called when the layer has been removed from the Map with Map#removeLayer.
         * This gives the layer a chance to clean up gl resources and event listeners.
         * @param map The Map this custom layer was just added to.
         * @param gl The gl context for the map.
         */
        onRemove?(map: TrimbleMaps.Map, gl: WebGLRenderingContext): void;

        /**
         * Optional method called when the layer has been added to the Map with Map#addLayer.
         * This gives the layer a chance to initialize gl resources and register event listeners.
         * @param map The Map this custom layer was just added to.
         * @param gl The gl context for the map.
         */
        onAdd?(map: TrimbleMaps.Map, gl: WebGLRenderingContext): void;

        /**
         * Optional method called during a render frame to allow a layer to prepare resources
         * or render into a texture.
         *
         * The layer cannot make any assumptions about the current GL state and must bind a framebuffer
         * before rendering.
         * @param gl The map's gl context.
         * @param matrix The map's camera matrix. It projects spherical mercator coordinates to gl
         *               coordinates. The mercator coordinate  [0, 0] represents the top left corner of
         *               the mercator world and  [1, 1] represents the bottom right corner. When the
         *               renderingMode is  "3d" , the z coordinate is conformal. A box with identical
         *               x, y, and z lengths in mercator units would be rendered as a cube.
         *               MercatorCoordinate .fromLatLng can be used to project a  LngLat to a mercator
         *               coordinate.
         */
        prerender?(gl: WebGLRenderingContext, matrix: number[]): void;

        /**
         * Called during a render frame allowing the layer to draw into the GL context.
         *
         * The layer can assume blending and depth state is set to allow the layer to properly blend
         * and clip other layers. The layer cannot make any other assumptions about the current GL state.
         *
         * If the layer needs to render to a texture, it should implement the prerender method to do this
         * and only use the render method for drawing directly into the main framebuffer.
         *
         * The blend function is set to gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA). This expects
         * colors to be provided in premultiplied alpha form where the r, g and b values are already
         * multiplied by the a value. If you are unable to provide colors in premultiplied form you may
         * want to change the blend function to
         * gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA).
         *
         * @param gl The map's gl context.
         * @param matrix The map's camera matrix. It projects spherical mercator coordinates to gl
         *               coordinates. The mercator coordinate  [0, 0] represents the top left corner of
         *               the mercator world and  [1, 1] represents the bottom right corner. When the
         *               renderingMode is  "3d" , the z coordinate is conformal. A box with identical
         *               x, y, and z lengths in mercator units would be rendered as a cube.
         *               MercatorCoordinate .fromLatLng can be used to project a  LngLat to a mercator
         *               coordinate.
         */
        render(gl: WebGLRenderingContext, matrix: number[]): void;
    }

    export interface StyleFunction {
        stops?: any[][];
        property?: string;
        base?: number;
        type?: 'identity' | 'exponential' | 'interval' | 'categorical';
        default?: any;
        colorSpace?: 'rgb' | 'lab' | 'hcl';
    }

    type Visibility = 'visible' | 'none';

    export interface Layout {
        visibility?: Visibility;
    }

    export interface BackgroundLayout extends Layout { }

    export interface BackgroundPaint {
        'background-color'?: string | Expression;
        'background-color-transition'?: Transition;
        'background-pattern'?: string;
        'background-pattern-transition'?: Transition;
        'background-opacity'?: number | Expression;
        'background-opacity-transition'?: Transition;
    }

    export interface FillLayout extends Layout {
        'fill-sort-key'?: number | Expression;
    }

    export interface FillPaint {
        'fill-antialias'?: boolean | Expression;
        'fill-opacity'?: number | StyleFunction | Expression;
        'fill-opacity-transition'?: Transition;
        'fill-color'?: string | StyleFunction | Expression;
        'fill-color-transition'?: Transition;
        'fill-outline-color'?: string | StyleFunction | Expression;
        'fill-outline-color-transition'?: Transition;
        'fill-translate'?: number[];
        'fill-translate-transition'?: Transition;
        'fill-translate-anchor'?: 'map' | 'viewport';
        'fill-pattern'?: string | Expression;
        'fill-pattern-transition'?: Transition;
    }

    export interface FillExtrusionLayout extends Layout { }

    export interface FillExtrusionPaint {
        'fill-extrusion-opacity'?: number | Expression;
        'fill-extrusion-opacity-transition'?: Transition;
        'fill-extrusion-color'?: string | StyleFunction | Expression;
        'fill-extrusion-color-transition'?: Transition;
        'fill-extrusion-translate'?: number[] | Expression;
        'fill-extrusion-translate-transition'?: Transition;
        'fill-extrusion-translate-anchor'?: 'map' | 'viewport';
        'fill-extrusion-pattern'?: string | Expression;
        'fill-extrusion-pattern-transition'?: Transition;
        'fill-extrusion-height'?: number | StyleFunction | Expression;
        'fill-extrusion-height-transition'?: Transition;
        'fill-extrusion-base'?: number | StyleFunction | Expression;
        'fill-extrusion-base-transition'?: Transition;
        'fill-extrusion-vertical-gradient'?: boolean;
    }

    export interface LineLayout extends Layout {
        'line-cap'?: 'butt' | 'round' | 'square';
        'line-join'?: 'bevel' | 'round' | 'miter' | Expression;
        'line-miter-limit'?: number | Expression;
        'line-round-limit'?: number | Expression;
        'line-sort-key'?: number | Expression;
    }

    export interface LinePaint {
        'line-opacity'?: number | StyleFunction | Expression;
        'line-opacity-transition'?: Transition;
        'line-color'?: string | StyleFunction | Expression;
        'line-color-transition'?: Transition;
        'line-translate'?: number[] | Expression;
        'line-translate-transition'?: Transition;
        'line-translate-anchor'?: 'map' | 'viewport';
        'line-width'?: number | StyleFunction | Expression;
        'line-width-transition'?: Transition;
        'line-gap-width'?: number | StyleFunction | Expression;
        'line-gap-width-transition'?: Transition;
        'line-offset'?: number | StyleFunction | Expression;
        'line-offset-transition'?: Transition;
        'line-blur'?: number | StyleFunction | Expression;
        'line-blur-transition'?: Transition;
        'line-dasharray'?: number[] | Expression;
        'line-dasharray-transition'?: Transition;
        'line-pattern'?: string | Expression;
        'line-pattern-transition'?: Transition;
        'line-gradient'?: Expression;
    }

    export interface SymbolLayout extends Layout {
        'symbol-placement'?: 'point' | 'line' | 'line-center';
        'symbol-spacing'?: number | Expression;
        'symbol-avoid-edges'?: boolean;
        'symbol-z-order'?: 'viewport-y' | 'source';
        'icon-allow-overlap'?: boolean | StyleFunction | Expression;
        'icon-ignore-placement'?: boolean;
        'icon-optional'?: boolean;
        'icon-rotation-alignment'?: 'map' | 'viewport' | 'auto';
        'icon-size'?: number | StyleFunction | Expression;
        'icon-text-fit'?: 'none' | 'both' | 'width' | 'height';
        'icon-text-fit-padding'?: number[] | Expression;
        'icon-image'?: string | StyleFunction | Expression;
        'icon-rotate'?: number | StyleFunction | Expression;
        'icon-padding'?: number | Expression;
        'icon-keep-upright'?: boolean;
        'icon-offset'?: number[] | StyleFunction | Expression;
        'icon-anchor'?: Anchor | StyleFunction | Expression;
        'icon-pitch-alignment'?: 'map' | 'viewport' | 'auto';
        'text-pitch-alignment'?: 'map' | 'viewport' | 'auto';
        'text-rotation-alignment'?: 'map' | 'viewport' | 'auto';
        'text-field'?: string | StyleFunction | Expression;
        'text-font'?: string | string[] | Expression;
        'text-size'?: number | StyleFunction | Expression;
        'text-max-width'?: number | StyleFunction | Expression;
        'text-line-height'?: number | Expression;
        'text-letter-spacing'?: number | Expression;
        'text-justify'?: 'left' | 'center' | 'right' | Expression;
        'text-anchor'?: Anchor | StyleFunction | Expression;
        'text-max-angle'?: number | Expression;
        'text-rotate'?: number | StyleFunction | Expression;
        'text-padding'?: number | Expression;
        'text-keep-upright'?: boolean;
        'text-transform'?: 'none' | 'uppercase' | 'lowercase' | StyleFunction | Expression;
        'text-offset'?: number[] | Expression;
        'text-allow-overlap'?: boolean;
        'text-ignore-placement'?: boolean;
        'text-optional'?: boolean;
        'text-radial-offset'?: number | Expression;
        'text-variable-anchor'?: Anchor[];
        'text-writing-mode'?: ('horizontal' | 'vertical')[];
        'symbol-sort-key'?: number | Expression;
    }

    export interface SymbolPaint {
        'icon-opacity'?: number | StyleFunction | Expression;
        'icon-opacity-transition'?: Transition;
        'icon-color'?: string | StyleFunction | Expression;
        'icon-color-transition'?: Transition;
        'icon-halo-color'?: string | StyleFunction | Expression;
        'icon-halo-color-transition'?: Transition;
        'icon-halo-width'?: number | StyleFunction | Expression;
        'icon-halo-width-transition'?: Transition;
        'icon-halo-blur'?: number | StyleFunction | Expression;
        'icon-halo-blur-transition'?: Transition;
        'icon-translate'?: number[] | Expression;
        'icon-translate-transition'?: Transition;
        'icon-translate-anchor'?: 'map' | 'viewport';
        'text-opacity'?: number | StyleFunction | Expression;
        'text-opacity-transition'?: Transition;
        'text-color'?: string | StyleFunction | Expression;
        'text-color-transition'?: Transition;
        'text-halo-color'?: string | StyleFunction | Expression;
        'text-halo-color-transition'?: Transition;
        'text-halo-width'?: number | StyleFunction | Expression;
        'text-halo-width-transition'?: Transition;
        'text-halo-blur'?: number | StyleFunction | Expression;
        'text-halo-blur-transition'?: Transition;
        'text-translate'?: number[] | Expression;
        'text-translate-transition'?: Transition;
        'text-translate-anchor'?: 'map' | 'viewport';
    }

    export interface RasterLayout extends Layout { }

    export interface RasterPaint {
        'raster-opacity'?: number | Expression;
        'raster-opacity-transition'?: Transition;
        'raster-hue-rotate'?: number | Expression;
        'raster-hue-rotate-transition'?: Transition;
        'raster-brightness-min'?: number | Expression;
        'raster-brightness-min-transition'?: Transition;
        'raster-brightness-max'?: number | Expression;
        'raster-brightness-max-transition'?: Transition;
        'raster-saturation'?: number | Expression;
        'raster-saturation-transition'?: Transition;
        'raster-contrast'?: number | Expression;
        'raster-contrast-transition'?: Transition;
        'raster-fade-duration'?: number | Expression;
        'raster-resampling'?: 'linear' | 'nearest';
    }

    export interface CircleLayout extends Layout {
        'circle-sort-key'?: number | Expression;
    }

    export interface CirclePaint {
        'circle-radius'?: number | StyleFunction | Expression;
        'circle-radius-transition'?: Transition;
        'circle-color'?: string | StyleFunction | Expression;
        'circle-color-transition'?: Transition;
        'circle-blur'?: number | StyleFunction | Expression;
        'circle-blur-transition'?: Transition;
        'circle-opacity'?: number | StyleFunction | Expression;
        'circle-opacity-transition'?: Transition;
        'circle-translate'?: number[] | Expression;
        'circle-translate-transition'?: Transition;
        'circle-translate-anchor'?: 'map' | 'viewport';
        'circle-pitch-scale'?: 'map' | 'viewport';
        'circle-pitch-alignment'?: 'map' | 'viewport';
        'circle-stroke-width'?: number | StyleFunction | Expression;
        'circle-stroke-width-transition'?: Transition;
        'circle-stroke-color'?: string | StyleFunction | Expression;
        'circle-stroke-color-transition'?: Transition;
        'circle-stroke-opacity'?: number | StyleFunction | Expression;
        'circle-stroke-opacity-transition'?: Transition;
    }

    export interface HeatmapLayout extends Layout { }

    export interface HeatmapPaint {
        'heatmap-radius'?: number | StyleFunction | Expression;
        'heatmap-radius-transition'?: Transition;
        'heatmap-weight'?: number | StyleFunction | Expression;
        'heatmap-intensity'?: number | StyleFunction | Expression;
        'heatmap-intensity-transition'?: Transition;
        'heatmap-color'?: string | StyleFunction | Expression;
        'heatmap-opacity'?: number | StyleFunction | Expression;
        'heatmap-opacity-transition'?: Transition;
    }

    export interface HillshadeLayout extends Layout { }

    export interface HillshadePaint {
        'hillshade-illumination-direction'?: number | Expression;
        'hillshade-illumination-anchor'?: 'map' | 'viewport';
        'hillshade-exaggeration'?: number | Expression;
        'hillshade-exaggeration-transition'?: Transition;
        'hillshade-shadow-color'?: string | Expression;
        'hillshade-shadow-color-transition'?: Transition;
        'hillshade-highlight-color'?: string | Expression;
        'hillshade-highlight-color-transition'?: Transition;
        'hillshade-accent-color'?: string | Expression;
        'hillshade-accent-color-transition'?: Transition;
    }

    interface RouteIconOptions {
        url?: string;
        size?: number;
        offset?: Array<number>;
        opacity: number;
        textOpacity: number;
    }

    interface RouteArrowOptions {
        size?: number;
        spacing?: number;
        fillColor?: string;
        fillOpacity?: number;
        strokeColor?: string;
        strokeWidth?: number;
        strokeOpacity?: number;
    }

    interface DragRouteOptions {
        snapKey?: typeof Common.SnapKey[keyof typeof Common.SnapKey];
        snapMode?: typeof Common.SnapMode[keyof typeof Common.SnapMode];
        viaPointModifierKey?: typeof Common.ViaPointModifierKey[keyof typeof Common.ViaPointModifierKey];
    }

    interface DateTimeType {
        calendarDate?: string;
        dayOfWeek?: typeof Common.DayOfWeek[keyof typeof Common.DayOfWeek];
        timeOfDay?: string;
        timeZone?: typeof Common.TimeZone[keyof typeof Common.TimeZone];
    }

    interface EstimatedTimeOptions {
        eTAETDType?: typeof Common.ETAETDType[keyof typeof Common.ETAETDType];
        dateOption?: typeof Common.DateOption[keyof typeof Common.DateOption];
        dateAndTime?: DateTimeType;
    }

    interface SharedOptions {
        estimatedTimeOptions?: EstimatedTimeOptions;
        useTraffic?: boolean;
        truckStyle?: typeof Common.TruckConfig[keyof typeof Common.TruckConfig];
        includeVehicleRestrictedCleanupPoints?: boolean;
    }

    interface RouteWidth {
        stops: Array<[number, number]>
    }

    export interface ReduceTripOptions {
        routePings: Array<LngLat>;
        offRouteMiles?: number;
        highwayOnly?: boolean; // This value will be ignored if routingOptions are supplied.
        reportType?: typeof Common.ReportType[keyof typeof Common.ReportType];
        region?: typeof Common.Region[keyof typeof Common.Region];
        routingOptions?: RouteOptionsBase;
        extendedOptions?: SharedOptions;
        callback: Callback<{ data: any }>;
    }

    export interface Address {
        streetAddress?: string;
        city?: string;
        state?: string;
        zip?: string;
        county?: string;
        country?: string;
        splc?: string;
    }

    export interface StopCost {
        costOfStop?: number;
        hoursPerStop?: number;
        loaded?: boolean;
        onDuty?: boolean;
        useOrigin?: boolean;
    }
    export interface StopOptions {
        id?: string;
        placeId?: string;
        label?: string;
        isViaPoint?: boolean;
        costs?: StopCost;
        lngLat: LngLatLike;
        address?: Address;
    }

    export interface RouteOptionsBase {
        vehicleType?: typeof Common.VehicleType[keyof typeof Common.VehicleType];
        routeType?: typeof Common.RouteType[keyof typeof Common.RouteType];
        routeOptimization?: typeof Common.RouteOptimization[keyof typeof Common.RouteOptimization];
        /* @deprecated */
        tollDiscourage?: boolean;
        tollRoads?: typeof Common.TollRoadsType[keyof typeof Common.TollRoadsType];
        afSetIDs?: Array<number>;
        afSetNames?: Array<string>;
        bordersOpen?: boolean;
        overrideRestrict?: boolean;
        highwayOnly?: boolean;
        hazMatType?: typeof Common.HazMatType[keyof typeof Common.HazMatType];
        hazMatTypes?: Array<typeof Common.HazMatType[keyof typeof Common.HazMatType]>;
        tunnelCategories?: Array<typeof Common.TunnelCategory[keyof typeof Common.TunnelCategory]>;
        customRoadSpeeds?: Array<RoadSpeedBase>;
        distanceUnits?: typeof Common.DistanceUnit[keyof typeof Common.DistanceUnit];
        // TruckCfg
        trkLCV?: boolean;
        trkUnits?: typeof Common.TruckUnit[keyof typeof Common.TruckUnit];
        trkHeight?: number | string;
        trkLength?: number | string;
        trkWidth?: number | string;
        trkWeight?: number | string;
        trkAxles?: number;
        trkMaxWeightPerAxleGroup?: number;
        trkTireCount?: number;
        ferryDiscourage?: boolean;
        elevLimit?: number;
        hosEnabled?: boolean;
        hosRemDriveTimeUntilBreak?: number;
        hosRemDriveTime?: number;
        hosRemOnDutyTime?: number;
        hosRuleType?: typeof Common.HoSScheduleType[keyof typeof Common.HoSScheduleType];
        hosRemCycleDutyTime?: number;

        hosCycleTimeGains?: Array<number>;
        hosLastCycleResetDateTime?: string;
        hosLast24HourBreakDateTime?: string;
        hosRemainingCanadaOnDutyTime?: number;
        hosRemainingDriveTimeUntilBreakDriver2?: number;
        hosRemainingDriveTimeDriver2?: number;
        hosRemainingOnDutyTimeDriver2?: number;
        hosRemainingCycleDutyTimeDriver2?: number;
        hosCycleTimeGainsDriver2?: Array<number>;
        hosLastCycleResetDateTimeDriver2?: string;
        hosLast24HourBreakDateTimeDriver2?: string;
        hosRemainingCanadaOnDutyTimeDriver2?: number;
        hosAlternateHoSRuleType?: number;
        hosRemainingTimeUntilFullDayBreak?: number;
        hosRemainingTimeUntilFullDayBreakDriver2?: number;
        hosRemainingDrivingTimeInWeek?: number;
        hosRemainingOnDutyTimeInDay?: number;
        hosRemainingConsecutiveDrivingTime?: number;
        hosRemainingFortnightlyTime?: number;
        hosCurrentOffDutyTime?: number;
        hosCurrentOffDutyTimeDriver2?: number;
        hosUseCycleReset?: boolean;
        hosTerminalDayStartTime?: string;
        hosUseCustomPlaces?: boolean;
        hosTeamDriving?: boolean;
        // CustomBreakDurations
        hosShortBreakDuration?: number;
        hosEndOfDutyBreakDuration?: number;
        hosCycleResetBreakDuration?: number;
        hosDriverSwitchBreakDuration?: number;
        hosBorderCrossingWaitDuration?: number;
        hosBreakTimeInDayDuration?: number;
        hosBreakTimeInWeekDuration?: number;

        hosMaxAlternateRestStops?: number;
        hosSkipRestStopInsertion?: boolean;
        hosActiveDriver?: number;
        hosMaxDrivingTimeInDay?: number;
        hosMaxOnDutyTimeInDay?: number;
        hosMaxOnDutyTimeInWeek?: number;
        hosAdverseConditionException?: boolean;
        hosPOIStopsReturned?: boolean;
        hosHOSWindowStart?: number;
        hosHOSWindowEnd?: number;

        maintainHeading?: boolean;
        sideOfStreetAdherence?: typeof Common.SideOfStreetAdherenceLevel[keyof typeof Common.SideOfStreetAdherenceLevel];
        governorSpeedLimit?: number;
        useAvoidsAndFavors?: boolean;
        useSites?: boolean;
        vehicleProfile?: typeof Common.TruckConfig[keyof typeof Common.TruckConfig];
        refrigerated?: boolean;
        fuelType?: typeof Common.FuelType[keyof typeof Common.FuelType];
        fuelConsumption?: number;
        trafficLookaheadDistance?: number;
        avoidState?: Array<string>;
        avoidCountry?: Array<string>;
        favorState?: Array<string>;
        favorCountry?: Array<string>;
        includeTrimblePlaceIDs?: boolean;
        useCrossStreetTurnAvoidance?: boolean;
        congestionZonesOpen?: boolean;
        lowEmissionZonesOpen?: boolean;
        displayRestrictions?: typeof Common.DisplayRestrictionsType[keyof typeof Common.DisplayRestrictionsType];
        profileName?: string;
        profileId?: number;
        // TrailerCfg
        trlType?: typeof Common.TrailerType[keyof typeof Common.TrailerType];
        trlCount?: number;
        trlMaxHt?: string;
        trlMaxWt?: number;
        trlMaxAxles?: number;
        // TrailerCfg.Engine
        isHybrid?: boolean;
        emiType?: typeof Common.EmissionType[keyof typeof Common.EmissionType];
        minPoll?: boolean;
        overrideClass?: typeof Common.ClassOverride[keyof typeof Common.ClassOverride];
        // RestrictionZones
        congestionZone?: typeof Common.ZoneType[keyof typeof Common.ZoneType];
        lowEmissionZone?: typeof Common.ZoneType[keyof typeof Common.ZoneType];
        ultraLowEmissionZone?: typeof Common.ZoneType[keyof typeof Common.ZoneType];
        hubRouting?: boolean;
    }

    export interface RouteOptions extends RouteOptionsBase {
        routeId?: string;
        routeColor?: string;
        routePathOpacity?: number;
        routeWidth?: RouteWidth | number;
        stops?: Array<LngLatLike | StopOptions>;
        inclFerryDist?: boolean;
        fuelUnits?: typeof Common.FuelUnit[keyof typeof Common.FuelUnit];
        truckConfig?: typeof Common.TruckConfig[keyof typeof Common.TruckConfig];
        inclTollData?: boolean;
        fuelEconLoad?: number;
        fuelEconEmpty?: number;
        costPerFuelUnit?: number;
        costGHG?: number;
        costMaintLoad?: number;
        costMaintEmpty?: number;
        costTimeLoad?: number;
        costTimeEmpty?: number;
        tollCurrency?: typeof Common.TollCurrency[keyof typeof Common.TollCurrency];
        exchangeRate?: number;
        tollPlan?: string;
        custRdSpeeds?: boolean;
        useEUTollsReport?: boolean;
        includeRoadClass?: boolean;
        useNonNaTolls?: boolean;
        citeInt?: number;
        region?: typeof Common.Region[keyof typeof Common.Region];
        dataVersion?: typeof Common.DataVersion[keyof typeof Common.DataVersion];
        reportType?: Array<typeof Common.ReportType[keyof typeof Common.ReportType]>;
        isDraggable?: boolean;
        dragOptions?: DragRouteOptions;
        originIcon?: RouteIconOptions;
        destinationIcon?: RouteIconOptions;
        stopIcon?: RouteIconOptions;
        assetId?: string;
        estimatedTimeOpts?: string;
        useTraffic?: boolean;
        includeVehicleRestrictedCleanupPoints?: boolean;
        frameRoute?: boolean;
        showStops?: boolean;
        requestMethod?: typeof Common.RequestMethod[keyof typeof Common.RequestMethod];
        frameOptions?: FitBoundsOptions;
        showArrows?: boolean;
        arrowOptions?: RouteArrowOptions;
        isVisible?: boolean;
        styleChangeFrameRoute?: boolean;

    }

    export interface RoadSpeedBase {
        roadCategory?: typeof Common.RoadType[keyof typeof Common.RoadType];
        speed?: number;
    }

    export class Route extends Evented {
        constructor(options?: RouteOptions);

        addTo(map: TrimbleMaps.Map): this;
        getBottomLayerId(): string | undefined;
        moveLayer(beforeId?: string): this;
        remove(): this;
        update(options: RouteOptions): void;
        frame(): this;
        /* @deprecated */
        frameRoute(): this;
        getRouteId(): string;
        getReports(options: RouteOptions): void;
        setDraggable(isDraggable: boolean): this;
        styleStopIcons(style: Object): void;
        addStopIcon(stopType: 'start' | 'end' | 'stop', url: string): void;
        getRouteWithNewStop(newStop: LngLat, routeLegPosition: number): void;
        canUndo(): boolean;
        canRedo(): boolean;
        undo(): void;
        redo(): void;
        enableRouteStack(): void;
        disableRouteStack(): void;
        toggleVisibility(): Route;
        setVisibility(isVisible: boolean): Route;
        setRouteState(isActive: boolean): Route;
        addStopMarkers(options: RouteOptions, isActive: boolean): Route
    }

    export interface ContentOptions {
        layerId: string;
        isVisible: boolean;
    }

    export interface ContentInterface {
        /**
         * Add the layer to a map.
         * @param {TrimbleMaps.Map} map
         */
        addTo(map: TrimbleMaps.Map): this;

        /**
         * Remove the layer from a map.
         */
        remove(): this;

        /**
         * Set the layer visibility.
         */
        setVisibility(isVisible: boolean): this;

        /**
         * Returns true if the layer is visible.
         */
        isVisible(): boolean;

        /**
         * Toggle layer visibility.
         */
        toggleVisibility(): this;
    }

    export interface RoadSurfaceRouteOptions {
        routeDuration: number; // The duration of the route in minutes (integer). This is required as it is used to calculate the temporal offset for each point in the route path.
        routePath: Array<LngLatLike>;
        provider: string; // Optional to switch provider from "Default" to "RC1".
        callback: Callback<{ data: any }>;
    }

    export class ContentBase implements ContentInterface {
        constructor(options?: ContentOptions);
        addTo(map: Map): this;
        remove(): this;
        setVisibility(isVisible: boolean): this;
        isVisible(): boolean;
        toggleVisibility(): this;
    }

    export class CustomRoad extends ContentBase { }

    export class TrafficCamera extends ContentBase { }

    export class TrafficIncident extends ContentBase { }

    export class TruckRestriction extends ContentBase { }

    export class WeatherRadar extends ContentBase { }

    export class WeatherCloud extends ContentBase { }

    export class Traffic extends ContentBase { }

    export class WeatherAlert extends ContentBase { }

    export class RoadSurface extends ContentBase { }

    export class PointsOfInterest extends ContentBase { }

    export type Cancelable = { cancel: () => void }
    export type Callback<Type> = (error: Error, result: Type) => void;

    export namespace Places {
        function authenticate(): Promise<string>;

        function getPlace(options: {
            token: string,
            placeId: string
        }): Promise<any>;

        function getPlaceDetails(options: {
            token: string,
            placeId: string
        }): Promise<any>;
    }

    export namespace DwellTimes {
        function getGlobalDwellTimes(options: {
            token?: string,
            placeId: string
        }): Promise<any>;
    }

    export namespace Geocoder {
        function geocode(geocodeOptions: {
            address: {
                addr?: string,
                city?: string,
                state?: string,
                zip?: string,
                country?: string,
                region?: string,
                dataset?: string,
                searchString?: string,
                postcodeFilter?: string,
                splc?: string
            },
            listSize?: number,
            success: (response: any) => void,
            failure?: (response: any) => void
        }): Cancelable;

        function reverseGeocode(reverseGeocodeOptions: {
            lonLat: LngLatLike,
            region?: string,
            dataset?: string,
            matchNamedRoadsOnly?: boolean,
            maxCleanupMiles?: number,
            success: (response: any) => void,
            failure?: (response: any) => void
        }): Cancelable;
    }

    export namespace Search {
        function singleSearch(options: {
            query: string, // required
            region?: string,
            maxResults?: number,
            currentLonLat?: LngLat,
            excludeResultsFor?: string, // excludedSearchTypes deprecated
            includeOnly?: string,
            poiCategories?: string,
            countries?: string,
            countryType?: string,
            states?: string,
            include?: string,
            useCustomPlaces?: boolean,
            separateHN?: boolean,
            getAllHNRanges?: boolean,
            includeTrimblePlaceIds?: boolean,
            lang?: string,
            matchNamedRoadsOnly?: boolean, // reverse geocoding only
            maxCleanupMiles?: number, // reverse geocoding only
            heading?: number // reverse geocoding only
        }): Promise<any>;
    }

    export namespace Routing {
        function postDerivedRoutePath(options: ReduceTripOptions): Cancelable;
        function postDerivedRouteReports(options: ReduceTripOptions): Cancelable;
        function postRoadSurfaceRoute(options: RoadSurfaceRouteOptions): Cancelable;
    }

    export class ClickControlBase implements IControl {
        constructor(options?: {});
        onAdd(map: Map): HTMLElement;
        onRemove(): void;
    }

    export class FilterControlBase implements IControl {
        onAdd(map: Map): HTMLElement;
        onRemove(): void;
        getFilter(): Array<any>;
    }
    export class RoadSurfaceLegendControl extends Control {
        constructor(options?: {});
    }
    export class WeatherAlertClickControl extends Control {
        constructor(options?: {});
    }

    export class WeatherAlertFilterControl extends Control {
        constructor(options?: {
            severity?: string, // TODO add values
            urgency?: string, // TODO add values
            certainty?: string, // TODO add values
            eventNames?: Array<string>,
            isVisible?: boolean
        });
    }
    
    export class PlaceClickControl extends ClickControlBase {
        constructor(options?: {});
    }
    export class TrafficCameraClickControl extends ClickControlBase {
        constructor(options?: {});
    }

    export class TrafficIncidentClickControl extends ClickControlBase {
        constructor(options?: {});
    }

    export class TrafficIncidentFilterControl extends FilterControlBase {
        constructor(options?: {
            incidentType?: string,
            isVisible?: boolean
        });
    }

    export class TruckRestrictionClickControl extends ClickControlBase {
        constructor(options?: {});
    }

    export class TruckRestrictionFilterControl extends FilterControlBase {
        constructor(options?: {
            category?: string,
            isVisible?: boolean
        });
    }

    /**************************/
    // Rail service
    export type RailStation = {
        format: typeof Common.RailStationFormat[keyof typeof Common.RailStationFormat];
        name: string;
        railroad: string;
    }

    export type RailRouteOptions = {
        routingPreference: typeof Common.RailRoutePreference[keyof typeof Common.RailRoutePreference];
        amtrakRoutes?: boolean;
        distUnit: typeof Common.RailDistanceUnit[keyof typeof Common.RailDistanceUnit];
        terminalSwitching?: boolean;
        intermodalOnlyStations?: boolean;
    }

    export type RailRouteRequest = {
        stops: Array<RailStation>;
        options: RailRouteOptions;
        callback: Callback<{ data: any }>;
    }

    export type RailStationRequest = {
        splc: string;
        callback: Callback<{ data: any }>;
    }

    export namespace Rail {
        function postRoutePath(options: RailRouteRequest): Cancelable;
        function getStations(options: RailStationRequest): Cancelable;
    }

    /**************************/
    // Common Enums

    export namespace Common {
        /**
         * Enumeration for map style values.
         */
        const Style: {
            DEFAULT: 'default',
            TRANSPORTATION: "transportation",
            SATELLITE: 'satellite',
            TERRAIN: 'terrain',
            BASIC: 'basic',
            BASIC_DARK: 'basic_dark',
            DATALIGHT: 'datalight',
            DATADARK: 'datadark',
            TRANSPORTATION_DARK: 'transportation_dark',
            ACCESSIBLE_LIGHT: 'light_accessible',
            ACCESSIBLE_DARK: 'dark_accessible',
            MOBILE_DAY: 'mobileday',
            MOBILE_NIGHT: 'mobilenight',
            MOBILE_SATELLITE: 'mobilesatellite',
            SIMPLE_LIGHT: 'simple_light',
            SIMPLE_DARK: 'simple_dark'
        }

        /**
         * Enumeration for map regions values.
         */
        const Region: {
            AF: 'af',
            AS: 'as',
            EU: 'eu',
            ME: 'me',
            NA: 'na',
            OC: 'oc',
            SA: 'sa',
            WW: 'ww'
        }
        /**
         * Enumeration for the routing vehicle type.
         */
        const VehicleType: {
            TRUCK: 0,
            LIGHT_TRUCK: 1,
            AUTOMOBILE: 2,
            MID_SIZE_TRUCK: 3,
            BUS: 4,
            RV: 5
        }
        /**
         * Enumeration for the route type.
         */
        const RouteType: {
            PRACTICAL: 0,
            SHORTEST: 1,
            FASTEST: 2
        }
        /**
         * Enumeration for the routing optimization.
         */
        const RouteOptimization: {
            NONE: 0,
            OPTIMIZE_ALL_STOPS: 1,
            OPTIMIZE_INTERMEDIATE_STOPS: 2
        }
        /**
         * Enumeration for the Class override.
         */
        const ClassOverride: {
            NONE: 0,
            FIFTY_THREE: 1,
            NATIONAL_NETWORK: 2,
            ALL: 3
        }
        /**
         * Enumeration for the routing HazMat type.
         */
        const HazMatType: {
            NONE: 0,
            GENERAL: 1,
            CAUSTIC: 2,
            EXPLOSIVES: 3,
            FLAMMABLE: 4,
            INHALANTS: 5,
            RADIOACTIVE: 6,
            HARMFUL_TO_WATER: 7,
            TUNNEL: 8
        }

         /**
         * Enumeration for the Satellite Provider types.
         */
         const SatelliteProvider:{
            DEFAULT: 'default',
            SAT1: 'sat1',
            SAT2: 'sat2',
            SAT3: 'sat3',
            SAT4: 'sat4',
            SAT5: 'sat5',
            SAT6: 'sat6',
            ALKCURATED: 'alkcurated'
         }

        /**
         * Represents the EU Tunnel categories. Applicable for EU region only.
         */
        const TunnelCategory: {
            NONE: 0,
            BCDE: 1,
            CDE: 2,
            DE: 3,
            E: 4
        }
        /**
         * Enumeration for the map units.
         */
        const Unit: {
            ENGLISH: 0,
            METRIC: 1
        }
        /**
         * Enumeration for the routing distance units.
         */
        const DistanceUnit: {
            MILES: 0,
            KILOMETERS: 1
        }
        /**
         * Enumeration for the routing truck units.
         */
        const TruckUnit: {
            ENGLISH: 0,
            METRIC: 1
        }
        /**
         * Enumeration for the routing fuel units.
         */
        const FuelUnit: {
            GALLONS: 0,
            LITERS: 1
        }

        const TruckConfig: {
            NONE: 0,
            TWENTY_EIGHT: 1,
            FORTY: 2,
            FORTY_EIGHT: 3,
            FIFTY_THREE: 4,
            FULL_SIZE_VAN: 5,
            TWENTY_SIX_STRAIGHT_TRUCK: 6,
            CONVENTIONAL_SCHOOL_BUS: 7,
            SMALL_SCHOOL_BUS: 8
        }
        /**
         * Enumeration for the routing currency units.
         */
        const TollCurrency: {
            USD: 0,
            CAD: 1,
            ALL: 2,
            AMD: 3,
            AZN: 4,
            BAM: 5,
            BGN: 6,
            BYR: 7,
            CHF: 8,
            CZK: 9,
            DKK: 10,
            EUR: 11,
            GBP: 12,
            GEL: 13,
            HRK: 14,
            HUF: 15,
            ISK: 16,
            MDL: 17,
            MKD: 18,
            NOK: 19,
            PLN: 20,
            RON: 21,
            RSD: 22,
            RUB: 23,
            SEK: 24,
            TRY: 25,
            UAH: 26
        }
        /**
         * Enumeration for the data version.
         */
        const DataVersion: {
            CURRENT: 'Current',
            EU: 'PCM_EU',
            OC: 'PCM_OC',
            SA: 'PCM_SA',
            NA: 'PCM_NA',
            AF: 'PCM_AF',
            AS: 'PCM_AS',
            ME: 'PCM_ME',
            /* @deprecated */
            IN: 'PCM_IN',
            /* @deprecated */
            SE: 'PCM_SE',
            JP: 'PCM_JP'
        }
        /**
         * Enumeration for the report type.
         */
        const ReportType: {
            ROAD: 'Road',
            MILEAGE: 'Mileage',
            DIRECTIONS: 'Directions',
            DETAIL: 'Detail',
            STATE: 'State',
            TOLL: 'TollDetail'
        }

        const Language: {
            AR: 'ar',
            BE: 'be',
            BG: 'bg',
            BN: 'bn',
            BS: 'bs',
            CA: 'ca',
            CS: 'cs',
            CY: 'cy',
            DA: 'da',
            DE: 'de',
            EL: 'el',
            EN: 'en',
            EN_AU: 'en-AU',
            EN_GB: 'en-GB',
            ES: 'es',
            ES_LA: 'es-LA',
            ET: 'et',
            EU: 'eu',
            FI: 'fi',
            FR: 'fr',
            GL: 'gl',
            HE: 'he',
            HI: 'hi',
            HR: 'hr',
            HU: 'hu',
            ID: 'id',
            IS: 'is',
            IT: 'it',
            JA: 'ja',
            KO: 'ko',
            LT: 'lt',
            LV: 'lv',
            MK: 'mk',
            MS: 'ms',
            MT: 'mt',
            NL: 'nl',
            NL_BE: 'nl-BE',
            NO: 'no',
            PL: 'pl',
            PT: 'pt',
            PT_BR: 'pt-BR',
            RO: 'ro',
            RU: 'ru',
            SK: 'sk',
            SL: 'sl',
            SQ: 'sq',
            SR: 'sr',
            SV: 'sv',
            TH: 'th',
            TR: 'tr',
            UK: 'uk',
            VI: 'vi',
            ZH: 'zh',
            ZH_HK: 'zh-HK',
            ZH_HANS: 'zh-Hans'
        }
        /**
         * Enumeration for trailer type.
         */
        const TrailerType: {
            NONE: 1,
            CARAVAN: 2,
            TRAILER: 3
        }
        /**
         * Enumeration for emission type of the engine.
         */
        const EmissionType: {
            EURO0: 2,
            EUROI: 3,
            EUROII: 4,
            EUROIII: 5,
            EUROIV: 6,
            EUROV: 7,
            EUROVI: 8,
            EUROEEV: 9
        }
        /**
         * HTTP request method.
         */
        const RequestMethod: {
            GET: 'GET',
            POST: 'POST'
        }
        /**
         * Estimated arrival and depart type
         */
        const ETAETDType: {
            ARRIVAL: 0,
            DEPART: 1
        }
        /**
         * Date option
         */
        const DateOption: {
            CURRENT: 0,
            SPECIFIC: 1,
            DAY_OF_WEEK: 2
        }
        /**
         *  Day of week option
         */
        const DayOfWeek: {
            SUNDAY: 0,
            MONDAY: 1,
            TUESDAY: 2,
            WEDNESDAY: 3,
            THURSDAY: 4,
            FRIDAY: 5,
            SATURDAY: 6
        }
        /**
         * Time zone option
         */
        const TimeZone: {
            LOCAL: 0,
            SYSTEM: 1,
            HAWAII: 2,
            ALASKA: 3,
            PACIFIC: 4,
            ARIZONA: 5,
            MOUNTAIN: 6,
            CENTRAL: 7,
            EASTERN: 8,
            ATLANTIC: 9,
            NEWFOUNDLAND: 10,
            GMT: 11,
            UTC: 12
        }
        /**
         * Data region option for derived route and report
         */
        const DataRegion: {
            UNKNOWN: 0,
            AF: 1,
            AS: 2,
            EU: 3,
            NA: 4,
            OC: 5,
            SA: 6,
            ME: 7,
            MX: 8
        }
        /**
         * Toll roads type
         */
        const TollRoadsType: {
            ALWAYS_AVOID: 1,
            AVOID_IF_POSSIBLE: 2,
            USE: 3
        }

        /**
         * Fuel type
         */
        const FuelType: {
            PETROL: 0,
            PETROL_E5: 1,
            PETROL_E10: 2,
            ETHANOL: 3,
            DIESEL: 4,
            BIODIESEL: 5,
            DIESEL_D5: 6,
            DIESEL_D7: 7,
            COUNT: 8
        }

        /**
         * Side of street adherence level
         */
        const SideOfStreetAdherenceLevel: {
            OFF: 0,
            MINIMAL: 1,
            MODERATE: 2,
            AVERAGE: 3,
            STRICT: 4,
            ADHERE: 5,
            STRONGLY_ADHERE: 6
        }

        /**
         * Represents which Hours Of Service rule to use
         */
        const HoSScheduleType: {
            US_FED_607_LH: 0,
            US_FED_708_LH: 1,
            CANADA_CYCLE_1: 2,
            CANADA_CYCLE_2: 3,
            CALIFORNIA_808: 4,
            TEXAS_707: 5,
            US_SHORT_HAUL: 6,
            EUROPE: 7,
            UNKNOWN: 8
        }

        /**
         * Display restrictions type
         */
        const DisplayRestrictionsType: {
            ALWAY_OFF: 0,
            ALWAY_ON: 1,
            BASED_ON_TRUCK_RESTRICTIONS: 2
        }

        /**
         * Represents the Euro Zone values
         */
        const ZoneType: {
            ALLOW: 0,
            WARN: 1,
            AVOID: 2
        }

        /**
         * Represents the type of roads for road speeds.
         */
        const RoadType: {
            // There is no 0
            INTER_STATE_RURAL: 1,
            // There is no 2
            DIVIDED_RURAL: 3,
            PRIMARY_RURAL: 4,
            FERRIES_RURAL: 5,
            SECONDARY_RURAL: 6,
            RAMP_RURAL: 7,
            LOCAL_RURAL: 8,
            // There is no 9
            INTER_STATE_URBAN: 10,
            // There is no 11
            DIVIDED_URBAN: 12,
            PRIMARY_URBAN: 13,
            FERRIES_URBAN: 14,
            SECONDARY_URBAN: 15,
            RAMP_URBAN: 16,
            LOCAL_URBAN: 17
        }

        /**************************/
        // Rail service

        /**
         * Rail station format
         */
        const RailStationFormat: {
            STATION_STATE: 'StationState',
            SPLC: 'SPLC',
            ERPC: 'ERPC',
            FSAC: 'FSAC',
            R260: 'R260'
        }
        /**
         * Rail route preference
         */
        const RailRoutePreference: {
            PRACTICAL: 'Practical',
            INTERMODAL: 'Intermodal',
            SHORTEST: 'Shortest',
            COAL_BULK: 'CoalBulk',
            AUTO_RACKS: 'AutoRacks',
            FUEL_SURCHARGE: 'FuelSurcharge'
        }
        /**
         * Rail distance unit
         */
        const RailDistanceUnit: {
            MILES: 'Miles',
            KILOMETERS: 'Kilometers'
        }

        /**
         * Used to indicate when drag routing will snap to visible roads.
         */
        const SnapMode: {
            OFF: 0,
            ENABLE_WITH_KEY: 1,
            DISABLE_WITH_KEY: 2
        }

        /**
         * The modifier key used by drag routing when snapping to visible roads.
         */
        const SnapKey: {
            SHIFT: 'shiftKey',
            CONTROL: 'ctrlKey',
            ALT: 'altKey'
        }

        /**
         * The modifier key used by removing via point flag introduced by drag routing.
         */
        const ViaPointModifierKey: {
            ALT: 'altKey',
            CONTROL: 'ctrlKey',
            SHIFT: 'shiftKey'
        }

    }
}
